using System;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using Reflector.Core.Describing.Models;

namespace Reflector.Core.Implementing
{
    public class ImplementationBuilder
    {
        private const string DynamicAssemblyName = "ReflectorDynamicAssembly";
        private const string ModuleBuilderName = "ReflectAutoGeneratedModule";

        private readonly ModuleBuilder _moduleBuilder;

        // Need to validate:
        // - Only methods and properties are allowed.
        // - Accessor must be a interface.

        // Handle InternalsVisibleTo
        // Handle generic types.

        public ImplementationBuilder()
        {
            var assemblyName = new AssemblyName(DynamicAssemblyName);
            var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);

            var moduleBuilder = assemblyBuilder.DefineDynamicModule(ModuleBuilderName);
            _moduleBuilder = moduleBuilder;
        }

        public TAccessor Implement<TAccessor>(object instance, IDispatcher dispatcher, AccessorDescription description) where TAccessor : ITypedReflectAccessor
        {
            var type = BuildImplementationType(description);

            var implementation = Activator.CreateInstance(type, dispatcher, instance);

            return (TAccessor) implementation;
        }

        // Bootstrapped from https://github.com/canton7/RestEase/blob/master/src/RestEase/Implementation/ImplementationBuilder.cs

        private Type BuildImplementationType(AccessorDescription description)
        {
            var accessorType = description.AccessorType;

            var implementationTypeName = CreateImplementationTypeName(accessorType);
            var typeBuilder = _moduleBuilder.DefineType(implementationTypeName, TypeAttributes.Public | TypeAttributes.Sealed);
            typeBuilder.AddInterfaceImplementation(accessorType);

            var dispatchFieldBuilder = typeBuilder.DefineField("_dispatch", typeof(IDispatcher), FieldAttributes.Private | FieldAttributes.InitOnly);
            var instanceFieldBuilder = typeBuilder.DefineField("_instance", typeof(object), FieldAttributes.Private | FieldAttributes.InitOnly);

            AddInstanceCtor(typeBuilder, dispatchFieldBuilder, instanceFieldBuilder);

            AddFieldAccessor(description.DispatcherProperty, typeBuilder, dispatchFieldBuilder);
            AddFieldAccessor(description.InstanceProperty, typeBuilder, instanceFieldBuilder);

            try
            {
                var constructedType = typeBuilder.CreateTypeInfo().AsType();
                return constructedType;
            }
            catch (TypeLoadException e)
            {
                // TODO
                throw;
            }
        }

        private string CreateImplementationTypeName(Type interfaceType)
        {
            var sb = new StringBuilder();
            // Make this unspeakable, just in case...
            sb.Append("Reflector.AutoGenerated.<>");
            AddFriendlierNameForType(sb, interfaceType);
            return sb.ToString();
        }

        private static void AddFriendlierNameForType(StringBuilder sb, Type type)
        {
            var typeInfo = type.GetTypeInfo();
            if (typeInfo.IsGenericType)
            {
                sb.Append(type.GetGenericTypeDefinition().FullName.Replace('.', '+'));
                sb.Append("<>["); // Just so that they can't fool us with carefully-crafted interface names...
                foreach (var arg in typeInfo.GetGenericArguments())
                {
                    AddFriendlierNameForType(sb, arg);
                }

                sb.Append("]");
            }
            else
            {
                sb.Append(type.FullName.Replace('.', '+'));
            }

            sb.Append("<>").Append(typeInfo.Assembly.GetName().Name.Replace('.', '+'));
        }

        private static void AddInstanceCtor(TypeBuilder typeBuilder, FieldBuilder dispatchFieldBuilder, FieldBuilder instanceFieldBuilder)
        {
            // public AccessorType(AccessorDispatch dispatch, object instance)
            // {
            //     _dispatch = dispatch;
            //     _instance = instance;
            // }

            // AccessorType..ctor:
            // ldarg.0     
            // call        System.Object..ctor   
            // ldarg.0     
            // ldarg.1     
            // stfld       _dispatch
            // ldarg.0     
            // ldarg.2     
            // stfld       _instance
            // ret         

            var ctorBuilder = typeBuilder.DefineConstructor(
                MethodAttributes.Public,
                CallingConventions.Standard,
                new[]
                {
                    typeof(IDispatcher),
                    typeof(object)
                }
            );

            var ctorIlGenerator = ctorBuilder.GetILGenerator();
            ctorIlGenerator.Emit(OpCodes.Ldarg_0);
            ctorIlGenerator.Emit(OpCodes.Ldarg_1);
            ctorIlGenerator.Emit(OpCodes.Stfld, dispatchFieldBuilder);
            ctorIlGenerator.Emit(OpCodes.Ldarg_0);
            ctorIlGenerator.Emit(OpCodes.Ldarg_2);
            ctorIlGenerator.Emit(OpCodes.Stfld, instanceFieldBuilder);
            ctorIlGenerator.Emit(OpCodes.Ret);
        }

        private static void AddFieldAccessor(PropertyInfo targetProperty, TypeBuilder typeBuilder, FieldBuilder fieldInfo)
        {
            const MethodAttributes propertyMethodAttributes =
                MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.SpecialName;

            var propertyBuilder = typeBuilder.DefineProperty(targetProperty.Name, PropertyAttributes.None, typeof(Dispatcher), null);
            var getter = typeBuilder.DefineMethod(targetProperty.GetMethod.Name, propertyMethodAttributes, targetProperty.PropertyType, new Type[0]);
            var getterIlGenerator = getter.GetILGenerator();
            getterIlGenerator.Emit(OpCodes.Ldarg_0);
            getterIlGenerator.Emit(OpCodes.Ldfld, fieldInfo);
            getterIlGenerator.Emit(OpCodes.Ret);
            propertyBuilder.SetGetMethod(getter);
        }
    }
}