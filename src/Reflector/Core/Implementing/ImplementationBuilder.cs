using System;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using Reflector.Core.Describing.Models;

namespace Reflector.Core.Implementing
{
    public class ImplementationBuilder
    {
        private const string DynamicAssemblyName = "ReflectorDynamicAssembly";
        private const string ModuleBuilderName = "ReflectAutoGeneratedModule";

        private readonly ModuleBuilder _moduleBuilder;

        // Need to validate:
        // - Only methods and properties are allowed.
        // - Accessor must be a interface.

        // Handle InternalsVisibleTo
        // Handle generic types.

        public ImplementationBuilder()
        {
            var assemblyName = new AssemblyName(DynamicAssemblyName);
            var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);

            var moduleBuilder = assemblyBuilder.DefineDynamicModule(ModuleBuilderName);
            _moduleBuilder = moduleBuilder;
        }

        public TAccessor Implement<TAccessor>(object instance, IDispatcher dispatcher, AccessorDescription description) where TAccessor : ITypedReflectAccessor
        {
            var type = BuildImplementationType(description);

            var implementation = Activator.CreateInstance(type, dispatcher, instance);

            return (TAccessor) implementation;
        }

        // Bootstrapped from https://github.com/canton7/RestEase/blob/master/src/RestEase/Implementation/ImplementationBuilder.cs

        private Type BuildImplementationType(AccessorDescription description)
        {
            var accessorType = description.AccessorType;

            var implementationTypeName = CreateImplementationTypeName(accessorType);
            var typeBuilder = _moduleBuilder.DefineType(implementationTypeName, TypeAttributes.Public | TypeAttributes.Sealed);
            typeBuilder.AddInterfaceImplementation(accessorType);

            var dispatchFieldBuilder = typeBuilder.DefineField("_dispatch", typeof(IDispatcher), FieldAttributes.Private | FieldAttributes.InitOnly);
            var instanceFieldBuilder = typeBuilder.DefineField("_instance", typeof(object), FieldAttributes.Private | FieldAttributes.InitOnly);

            AddInstanceCtor(typeBuilder, dispatchFieldBuilder, instanceFieldBuilder);

            AddFieldAccessor(description.DispatcherProperty, typeBuilder, dispatchFieldBuilder);
            AddFieldAccessor(description.InstanceProperty, typeBuilder, instanceFieldBuilder);

            foreach (var member in description.Members)
            {
                var id = member.Key;
                var memberDescription = member.Value;
                switch (memberDescription)
                {
                    case PropertyDescription propertyDescription:
                        AddPropertyDispatch(id, propertyDescription, typeBuilder, instanceFieldBuilder, dispatchFieldBuilder);
                        break;
                    case FieldDescription fieldDescription:
                        AddFieldDispatch(id, fieldDescription, typeBuilder, instanceFieldBuilder, dispatchFieldBuilder);
                        break;
                    case MethodDescription methodDescription:
                        AddMethodDispatch(id, methodDescription, typeBuilder, instanceFieldBuilder, dispatchFieldBuilder);
                        break;
                }
            }

            try
            {
                var constructedType = typeBuilder.CreateTypeInfo().AsType();
                return constructedType;
            }
            catch (TypeLoadException e)
            {
                // TODO
                throw;
            }
        }

        private string CreateImplementationTypeName(Type interfaceType)
        {
            var sb = new StringBuilder();
            // Make this unspeakable, just in case...
            sb.Append("Reflector.AutoGenerated.<>");
            AddFriendlierNameForType(sb, interfaceType);
            return sb.ToString();
        }

        private static void AddFriendlierNameForType(StringBuilder sb, Type type)
        {
            var typeInfo = type.GetTypeInfo();
            if (typeInfo.IsGenericType)
            {
                sb.Append(type.GetGenericTypeDefinition().FullName.Replace('.', '+'));
                sb.Append("<>["); // Just so that they can't fool us with carefully-crafted interface names...
                foreach (var arg in typeInfo.GetGenericArguments())
                {
                    AddFriendlierNameForType(sb, arg);
                }

                sb.Append("]");
            }
            else
            {
                sb.Append(type.FullName.Replace('.', '+'));
            }

            sb.Append("<>").Append(typeInfo.Assembly.GetName().Name.Replace('.', '+'));
        }

        private static void AddInstanceCtor(TypeBuilder typeBuilder, FieldBuilder dispatchFieldBuilder, FieldBuilder instanceFieldBuilder)
        {
            // public AccessorType(AccessorDispatch dispatch, object instance)
            // {
            //     _dispatch = dispatch;
            //     _instance = instance;
            // }

            // AccessorType..ctor:
            // ldarg.0     
            // call        System.Object..ctor   
            // ldarg.0     
            // ldarg.1     
            // stfld       _dispatch
            // ldarg.0     
            // ldarg.2     
            // stfld       _instance
            // ret         

            var ctorBuilder = typeBuilder.DefineConstructor(
                MethodAttributes.Public,
                CallingConventions.Standard,
                new[]
                {
                    typeof(IDispatcher),
                    typeof(object)
                }
            );

            var ctorIlGenerator = ctorBuilder.GetILGenerator();
            ctorIlGenerator.Emit(OpCodes.Ldarg_0);
            ctorIlGenerator.Emit(OpCodes.Ldarg_1);
            ctorIlGenerator.Emit(OpCodes.Stfld, dispatchFieldBuilder);
            ctorIlGenerator.Emit(OpCodes.Ldarg_0);
            ctorIlGenerator.Emit(OpCodes.Ldarg_2);
            ctorIlGenerator.Emit(OpCodes.Stfld, instanceFieldBuilder);
            ctorIlGenerator.Emit(OpCodes.Ret);
        }

        private static void AddFieldAccessor(PropertyInfo targetProperty, TypeBuilder typeBuilder, FieldInfo fieldInfo)
        {
            const MethodAttributes propertyMethodAttributes =
                MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.SpecialName;

            var propertyBuilder = typeBuilder.DefineProperty(targetProperty.Name, PropertyAttributes.None, typeof(Dispatcher), null);
            var getter = typeBuilder.DefineMethod(targetProperty.GetMethod!.Name, propertyMethodAttributes, targetProperty.PropertyType, new Type[0]);
            var getterIlGenerator = getter.GetILGenerator();
            getterIlGenerator.Emit(OpCodes.Ldarg_0);
            getterIlGenerator.Emit(OpCodes.Ldfld, fieldInfo);
            getterIlGenerator.Emit(OpCodes.Ret);
            propertyBuilder.SetGetMethod(getter);
        }

        private static void AddPropertyDispatch(int id, PropertyDescription description, TypeBuilder typeBuilder, FieldInfo instanceField,
                                                FieldInfo dispatcherField)
        {
            const MethodAttributes propertyMethodAttributes =
                MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.SpecialName;

            var sourceProperty = description.SourceProperty;
            var propertyBuilder = typeBuilder.DefineProperty(sourceProperty.Name, PropertyAttributes.None, sourceProperty.PropertyType, null);

            if (sourceProperty.CanRead)
            {
                var getter = typeBuilder.DefineMethod(
                    sourceProperty.GetMethod!.Name,
                    propertyMethodAttributes,
                    sourceProperty.PropertyType,
                    new Type[0]
                );
                var generator = getter.GetILGenerator();
                generator.Emit(OpCodes.Ldarg_0); // this
                generator.Emit(OpCodes.Ldfld, dispatcherField); // this._dispatcher
                generator.Emit(OpCodes.Ldarg_0); // this
                generator.Emit(OpCodes.Ldfld, instanceField); // this._instance
                generator.Emit(OpCodes.Ldc_I4, id);
                generator.Emit(OpCodes.Callvirt, typeof(IDispatcher).GetMethod(nameof(IDispatcher.PropertyGet))!);
                generator.Emit(OpCodes.Ret);
                propertyBuilder.SetGetMethod(getter);
            }

            if (sourceProperty.CanWrite)
            {
                var setter = typeBuilder.DefineMethod(
                    sourceProperty.SetMethod!.Name,
                    propertyMethodAttributes,
                    null,
                    new[] { sourceProperty.PropertyType }
                );
                var generator = setter.GetILGenerator();
                generator.Emit(OpCodes.Ldarg_0); // this
                generator.Emit(OpCodes.Ldfld, dispatcherField); // this._dispatcher
                generator.Emit(OpCodes.Ldarg_0); // this
                generator.Emit(OpCodes.Ldfld, instanceField); // this._instance
                generator.Emit(OpCodes.Ldc_I4, id);
                generator.Emit(OpCodes.Ldarg_1); // value
                generator.Emit(OpCodes.Callvirt, typeof(IDispatcher).GetMethod(nameof(IDispatcher.PropertySet))!);
                generator.Emit(OpCodes.Ret);
                propertyBuilder.SetSetMethod(setter);
            }
        }

        private static void AddFieldDispatch(int id, FieldDescription description, TypeBuilder typeBuilder, FieldInfo instanceField, FieldInfo dispatcherField)
        {
            const MethodAttributes propertyMethodAttributes =
                MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.SpecialName;

            var sourceProperty = description.SourceProperty;
            var propertyBuilder = typeBuilder.DefineProperty(sourceProperty.Name, PropertyAttributes.None, sourceProperty.PropertyType, null);

            if (sourceProperty.CanRead)
            {
                var getter = typeBuilder.DefineMethod(
                    sourceProperty.GetMethod!.Name,
                    propertyMethodAttributes,
                    sourceProperty.PropertyType,
                    new Type[0]
                );
                var generator = getter.GetILGenerator();
                generator.Emit(OpCodes.Ldarg_0); // this
                generator.Emit(OpCodes.Ldfld, dispatcherField); // this._dispatcher
                generator.Emit(OpCodes.Ldarg_0); // this
                generator.Emit(OpCodes.Ldfld, instanceField); // this._instance
                generator.Emit(OpCodes.Ldc_I4, id);
                generator.Emit(OpCodes.Callvirt, typeof(IDispatcher).GetMethod(nameof(IDispatcher.FieldGet))!);
                generator.Emit(OpCodes.Ret);
                propertyBuilder.SetGetMethod(getter);
            }

            if (sourceProperty.CanWrite)
            {
                var setter = typeBuilder.DefineMethod(
                    sourceProperty.SetMethod!.Name,
                    propertyMethodAttributes,
                    null,
                    new[] { sourceProperty.PropertyType }
                );
                var generator = setter.GetILGenerator();
                generator.Emit(OpCodes.Ldarg_0); // this
                generator.Emit(OpCodes.Ldfld, dispatcherField); // this._dispatcher
                generator.Emit(OpCodes.Ldarg_0); // this
                generator.Emit(OpCodes.Ldfld, instanceField); // this._instance
                generator.Emit(OpCodes.Ldc_I4, id);
                generator.Emit(OpCodes.Ldarg_1); // value
                generator.Emit(OpCodes.Callvirt, typeof(IDispatcher).GetMethod(nameof(IDispatcher.FieldSet))!);
                generator.Emit(OpCodes.Ret);
                propertyBuilder.SetSetMethod(setter);
            }
        }

        private static void AddMethodDispatch(int id, MethodDescription description, TypeBuilder typeBuilder, FieldInfo instanceField,
                                              FieldInfo dispatcherField)
        {
            const MethodAttributes methodAttributes = MethodAttributes.Public | MethodAttributes.Virtual;

            var source = description.SourceMethod;
            var parameters = source.GetParameters().Select(x => x.ParameterType).ToArray();
            var methodBuilder = typeBuilder.DefineMethod(
                source.Name,
                methodAttributes,
                CallingConventions.HasThis | CallingConventions.Standard,
                source.ReturnType,
                parameters
            );

            var generator = methodBuilder.GetILGenerator();
            generator.Emit(OpCodes.Ldarg_0); // this
            generator.Emit(OpCodes.Ldfld, dispatcherField); // this._dispatcher
            generator.Emit(OpCodes.Ldarg_0); // this
            generator.Emit(OpCodes.Ldfld, instanceField); // this._instance
            generator.Emit(OpCodes.Ldc_I4, id);

            generator.Emit(OpCodes.Ldc_I4, parameters.Length);
            generator.Emit(OpCodes.Newarr, typeof(object)); // var array = new object[param.length]

            for (var i = 0; i < parameters.Length; i++)
            {
                generator.Emit(OpCodes.Dup); // array
                generator.Emit(OpCodes.Ldc_I4, i);
                generator.Emit(OpCodes.Ldarg, i + 1);
                generator.Emit(OpCodes.Stelem_Ref); // array[i] = param[i]
            }

            var method = typeof(IDispatcher).GetMethod(nameof(IDispatcher.MethodCall));
            generator.Emit(OpCodes.Callvirt, method);

            if (methodBuilder.ReturnType == typeof(void))
            {
                generator.Emit(OpCodes.Pop);
            }

            generator.Emit(OpCodes.Ret);
        }
    }
}